<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>molgri.grids API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>molgri.grids</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from abc import ABC, abstractmethod

import networkx as nx
import numpy as np
from scipy.constants import pi, golden
from scipy.spatial import distance_matrix
from scipy.spatial.distance import cdist
import pandas as pd

from .analysis import random_sphere_points, random_axes_count_points
from .utils import dist_on_sphere
from .constants import DEFAULT_SEED, SIX_METHOD_NAMES, UNIQUE_TOL, ENDING_GRID_FILES
from .parsers import NameParser, TranslationParser
from .paths import PATH_OUTPUT_ROTGRIDS, PATH_OUTPUT_STAT
from .rotations import grid2quaternion, grid2euler, quaternion2grid, euler2grid
from .wrappers import time_method


class Polytope(ABC):

    def __init__(self):
        &#34;&#34;&#34;
        A polytope is a 3-dim object consisting of a set of vertices and connections between them (edges) saved
        in self.G property.
        &#34;&#34;&#34;
        self.G = nx.Graph()
        self.faces = []
        self.current_level = 0
        self.side_len = 0
        self._create_level0()

    @abstractmethod
    def _create_level0(self):
        &#34;&#34;&#34;This is implemented by each subclass since they have different edges, vertices and faces&#34;&#34;&#34;

    def plot_graph(self):
        &#34;&#34;&#34;
        Plot the networkx graph of self.G.
        &#34;&#34;&#34;
        node_labels = {i: tuple(np.round(i, 3)) for i in self.G.nodes}
        nx.draw_networkx(self.G, pos=nx.circular_layout(self.G), with_labels=True, labels=node_labels)

    def plot_points(self, ax, select_faces: set = None, projection: bool = False):
        &#34;&#34;&#34;
        Plot the points of the icosahedron + possible division points. Colored by level at which the point was added.
        Possible to select only one or a few faces on which points are to be plotted for clarity.

        Args:
            ax: axis
            select_faces: a set of face numbers from 0 to (incl) 19, e.g. {0, 5}. If None, all faces are shown.
            projection: True if you want to plot the projected points, not the ones on surfaces of polytope
        &#34;&#34;&#34;
        select_faces = set(range(20)) if select_faces is None else select_faces
        level_color = [&#34;black&#34;, &#34;red&#34;, &#34;blue&#34;, &#34;green&#34;]
        for point in self.G.nodes(data=True):
            # select only points that belong to at least one of the chosen select_faces
            if len(set(point[1][&#34;face&#34;]).intersection(select_faces)) &gt; 0:
                # color selected based on the level of the node
                level_node = point[1][&#34;level&#34;]
                if projection:
                    proj_node = point[1][&#34;projection&#34;]
                    ax.scatter(*proj_node[0], color=level_color[level_node], s=30)
                else:
                    ax.scatter(*point[0], color=level_color[level_node], s=30)

    def plot_edges(self, ax, select_faces=None, **kwargs):
        &#34;&#34;&#34;
        Plot the edges between the points. Can select to display only some faces for clarity.

        Args:
            ax: axis
            select_faces: a set of face numbers from 0 to (incl) 19, e.g. {0, 5}. If None, all faces are shown.
            **kwargs: other plotting arguments
        &#34;&#34;&#34;
        select_faces = set(range(20)) if select_faces is None else select_faces
        for edge in self.G.edges:
            faces_edge_1 = set(self.G.nodes[edge[0]][&#34;face&#34;])
            faces_edge_2 = set(self.G.nodes[edge[1]][&#34;face&#34;])
            # both the start and the end point of the edge must belong to one of the selected faces
            if len(faces_edge_1.intersection(select_faces)) &gt; 0 and len(faces_edge_2.intersection(select_faces)) &gt; 0:
                ax.plot(*np.array(edge).T, color=&#34;black&#34;,  **kwargs)

    def divide_edges(self):
        &#34;&#34;&#34;
        Subdivide once. If previous faces are triangles, adds three points per face (half sides). If they are
        squares, adds 4 points per face (half sides + middle). New points will have a higher level and will
        be appropriately added to one or more faces (if on edges).
        &#34;&#34;&#34;
        # need to keep track of what to add/remove, since we can&#39;t change the network while inside the loop
        # consists of (new_point, previous_point_1, previous_point_2) to keep all info
        nodes_to_add = []
        for node_vector in self.G.nodes():
            for neighbour_vector in self.G.neighbors(node_vector):
                # this is just to avoid doing everything twice - do it for edge A-B but not B-A
                if node_vector &lt; neighbour_vector:
                    # new point is just the average of the previous two
                    new_point = tuple((np.array(node_vector)+np.array(neighbour_vector))/2.0)
                    nodes_to_add.append((new_point, node_vector, neighbour_vector))
        # add new nodes, add edges from cont. points to the node and delete the edge between the cont. points
        for el in nodes_to_add:
            new_point, node_vector, neighbour_vector = el
            # new point will have the set of faces that both node and neighbour vector have
            faces_node_vector = self.G.nodes[node_vector][&#34;face&#34;]
            faces_neighbour_vector = self.G.nodes[neighbour_vector][&#34;face&#34;]
            # diagonals get added twice, so this is necessary
            if new_point not in self.G.nodes:
                self.G.add_node(new_point, level=self.current_level + 1,
                                face=set(faces_node_vector).intersection(faces_neighbour_vector),
                                projection=project_grid_on_sphere(np.array(new_point)[np.newaxis, :]))
            self.G.add_edge(new_point, neighbour_vector,
                            length=dist_on_sphere(self.G.nodes[new_point][&#34;projection&#34;],
                                                  self.G.nodes[neighbour_vector][&#34;projection&#34;]))
            self.G.add_edge(new_point, node_vector,
                            length=dist_on_sphere(self.G.nodes[new_point][&#34;projection&#34;],
                                                  self.G.nodes[neighbour_vector][&#34;projection&#34;]))
            # self.G.remove_edge(node_vector, neighbour_vector)
        # also add edges between new nodes at distance side_len or sqrt(2)*side_len
        new_level = [x for x, y in self.G.nodes(data=True) if y[&#39;level&#39;] == self.current_level+1]
        for new_node in new_level:
            # searching only second neighbours at appropriate level
            sec_neighbours = list(second_neighbours(self.G, new_node))
            sec_neighbours = [x for x in sec_neighbours if self.G.nodes[x][&#34;level&#34;] == self.current_level+1]
            for other_node in sec_neighbours:
                node_dist = np.linalg.norm(np.array(new_node)-np.array(other_node))
                # check distance criterion
                if np.isclose(node_dist, self.side_len) or np.isclose(node_dist, self.side_len*np.sqrt(2)):
                    self.G.add_edge(new_node, other_node,
                                    length=dist_on_sphere(self.G.nodes[new_node][&#34;projection&#34;],
                                                          self.G.nodes[other_node][&#34;projection&#34;])
                                    )
        self.current_level += 1
        self.side_len = self.side_len / 2


class IcosahedronPolytope(Polytope):
    &#34;&#34;&#34;
    IcosahedronGrid is a graph object, its central feature is self.G (networkx graph). In the beginning, each node is
    a vertex of a 3D icosahedron. It is possible to subdivide the sides, in that case a new point always appears in the
    middle of each triangle side.
    &#34;&#34;&#34;

    def _create_level0(self):
        # DO NOT change order of points - faces will be wrong!
        # each face contains numbers - indices of vertices that border on this face
        self.faces = [[0, 11, 5],
                      [0, 5, 1],
                      [0, 1, 7],
                      [0, 7, 10],
                      [0, 10, 11],
                      [1, 5, 9],
                      [5, 11, 4],
                      [11, 10, 2],
                      [10, 7, 6],
                      [7, 1, 8],
                      [3, 9, 4],
                      [3, 4, 2],
                      [3, 2, 6],
                      [3, 6, 8],
                      [3, 8, 9],
                      [4, 9, 5],
                      [2, 4, 11],
                      [6, 2, 10],
                      [8, 6, 7],
                      [9, 8, 1]]
        side_len = 1 / np.sin(2 * pi / 5)
        self.side_len = side_len
        # create vertices
        vertices = [(-1, golden, 0), (1, golden, 0), (-1, -golden, 0), (1, -golden, 0),
                    (0, -1, golden), (0, 1, golden), (0, -1, -golden), (0, 1, -golden),
                    (golden, 0, -1), (golden, 0, 1), (-golden, 0, -1), (-golden, 0, 1)]
        vertices = np.array(vertices) * side_len / 2
        # create edges
        point_connections = _calc_edges(vertices, side_len)
        # add vertices and edges to the graph
        for i, vert in enumerate(vertices):
            set_of_faces = tuple(faces_i for faces_i, face in enumerate(self.faces) if i in face)
            self.G.add_node(tuple(vert), level=self.current_level, face=set_of_faces,
                            projection=project_grid_on_sphere(vert[np.newaxis, :]))
        for key, value in point_connections.items():
            for vi in value:
                self.G.add_edge(key, tuple(vi),
                                length=dist_on_sphere(self.G.nodes[key][&#34;projection&#34;],
                                                      self.G.nodes[tuple(vi)][&#34;projection&#34;]))
        # just to check ...
        assert self.G.number_of_nodes() == 12
        assert self.G.number_of_edges() == 30
        for node in self.G.nodes(data=True):
            assert len(node[1][&#34;face&#34;]) == 5 and node[1][&#34;level&#34;] == 0
        self.side_len = side_len / 2


class CubePolytope(Polytope):
    &#34;&#34;&#34;
    CubeGrid is a graph object, its central feature is self.G (networkx graph). In the beginning, each node is
    a vertex of a 3D cube. It is possible to subdivide the sides, in that case a new point always appears in the
    middle of a square and half of previous sides.
    &#34;&#34;&#34;

    def _create_level0(self):
        # DO NOT change order of points - faces will be wrong!
        # each face contains numbers - indices of vertices that border on this face
        self.faces = [[0, 1, 2, 4],
                      [0, 2, 3, 6],
                      [0, 1, 3, 5],
                      [3, 5, 6, 7],
                      [1, 4, 5, 7],
                      [2, 4, 6, 7]]
        self.side_len = 2 * np.sqrt(1/3)
        # create vertices
        vertices = [(-self.side_len/2, -self.side_len/2, -self.side_len/2),
                    (-self.side_len/2, -self.side_len/2, self.side_len/2),
                    (-self.side_len/2, self.side_len/2, -self.side_len/2),
                    (self.side_len/2, -self.side_len/2, -self.side_len/2),
                    (-self.side_len/2, self.side_len/2, self.side_len/2),
                    (self.side_len/2, -self.side_len/2, self.side_len/2),
                    (self.side_len/2, self.side_len/2, -self.side_len/2),
                    (self.side_len/2, self.side_len/2, self.side_len/2)]
        vertices = np.array(vertices)
        # create edges
        point_connections = _calc_edges(vertices, self.side_len)
        # add vertices and edges to the graph
        for i, vert in enumerate(vertices):
            set_of_faces = tuple(faces_i for faces_i, face in enumerate(self.faces) if i in face)
            self.G.add_node(tuple(vert), level=self.current_level, face=set_of_faces,
                            projection=project_grid_on_sphere(vert[np.newaxis, :]))
        for key, value in point_connections.items():
            for vi in value:
                self.G.add_edge(key, tuple(vi),
                                length=dist_on_sphere(self.G.nodes[key][&#34;projection&#34;],
                                                      self.G.nodes[tuple(vi)][&#34;projection&#34;]))
        # just to check ...
        assert self.G.number_of_nodes() == 8
        assert self.G.number_of_edges() == 24
        for node in self.G.nodes(data=True):
            assert len(node[1][&#34;face&#34;]) == 3 and node[1][&#34;level&#34;] == 0
        self.side_len = self.side_len / 2


def _calc_edges(vertices: np.ndarray, side_len: float) -&gt; dict:
    &#34;&#34;&#34;
    Needed for the determination of edges while setting up a polytope. If a bit weird, keep in mind this is a legacy
    function. Do not use on its own.

    Args:
        vertices: an array of polytope vertices
        side_len: everything &lt; sqrt(2)*side_len apart will be considered a neighbour

    Returns:
        a dictionary, key is the vertex, values are its neighbours
    &#34;&#34;&#34;
    dist = distance_matrix(vertices, vertices)
    # filter points more than 0 and less than sqrt(2)*side away from each other
    # this gives exactly triangles and squares as neighbours
    where_result = np.where((dist &lt;= np.sqrt(2)*side_len) &amp; (0 &lt; dist))
    indices_min_dist = zip(where_result[0], where_result[1])
    # key is the vertex, values are its neighbours
    tree_connections = {tuple(vert): [] for vert in vertices}
    for i1, i2 in indices_min_dist:
        tree_connections[tuple(vertices[i1])].append(vertices[i2])
    return tree_connections


def second_neighbours(graph: nx.Graph, node):
    &#34;&#34;&#34;Yield second neighbors of node in graph. Ignore second neighbours that are also first neighbours.
    Second neighbors may repeat!

    Example:

        5------6
        |      |
        2 ---- 1 ---- 3 ---- 7
               |      |
               \--8--/

    First neighbours of 1: 2, 6, 3, 8
    Second neighbours of 1: 5, 7
    &#34;&#34;&#34;
    direct_neighbours = list(graph.neighbors(node))
    for neighbor_list in [graph.neighbors(n) for n in direct_neighbours]:
        for n in neighbor_list:
            if n != node and n not in direct_neighbours:
                yield n


class Grid(ABC):

    def __init__(self, N: int, *, ordered: bool = True, use_saved: bool = False, gen_alg: str = None,
                 time_generation: bool = False):
        &#34;&#34;&#34;
        Generate a grid with one of generation algorithms.

        Args:
            gen_alg: MUST BE SET IN SUBCLASSES, algorithm name, see names given in SIX_METHOD_NAMES
            N: number of grid points
            ordered: if True order and truncate, else only truncate to N points
            use_saved: if True use saved grids if available
            time_generation: if True write out a message about time needed for generation
        &#34;&#34;&#34;
        self.rn_gen = np.random.default_rng(DEFAULT_SEED)
        np.random.seed(DEFAULT_SEED)
        assert gen_alg in SIX_METHOD_NAMES or gen_alg == &#34;zero&#34;, f&#34;{gen_alg} is not a valid generation algorithm name&#34;
        self.ordered = ordered
        self.N = N
        name_properties = {&#34;grid_type&#34;: gen_alg, &#34;num_grid_points&#34;: N, &#34;ordering&#34;: ordered}
        self.standard_name = NameParser(name_properties).get_standard_name()
        self.decorator_label = f&#34;rotation grid {self.standard_name}&#34;
        self.grid = None
        self.time = 0
        self.nn_dist_arch = None
        self.nn_dist_cup = None
        self.short_statistics_path = f&#34;{PATH_OUTPUT_STAT}{self.standard_name}_short_stat.txt&#34;
        self.statistics_path = f&#34;{PATH_OUTPUT_STAT}{self.standard_name}_full_stat.csv&#34;
        gen_func = self.generate_and_time if time_generation else self.generate_grid
        # if this option enabled, search first if this grid has already been saved
        if use_saved:
            try:
                self.grid = np.load(f&#34;{PATH_OUTPUT_ROTGRIDS}{self.standard_name}.npy&#34;)
            except FileNotFoundError:
                gen_func()
                self.save_grid()
        else:
            gen_func()
        assert isinstance(self.grid, np.ndarray), &#34;A grid must be a numpy array!&#34;
        assert self.grid.shape == (N, 3), f&#34;Grid not of correct shape! {self.grid.shape} instead of {(N, 3)}&#34;
        assert np.allclose(np.linalg.norm(self.grid, axis=1), 1, atol=10**(-UNIQUE_TOL))

    def get_grid(self) -&gt; np.ndarray:
        return self.grid

    @abstractmethod
    def generate_grid(self):
        # order or truncate
        if self.ordered:
            self._order()
        else:
            self.grid = self.grid[:self.N]

    @time_method
    def generate_and_time(self):
        self.generate_grid()

    def _order(self):
        self.grid = order_grid_points(self.grid, self.N)

    def as_quaternion(self) -&gt; np.ndarray:
        quaternion_seq = grid2quaternion(self.grid)
        assert isinstance(quaternion_seq, np.ndarray), &#34;A quaternion sequence must be a numpy array!&#34;
        assert quaternion_seq.shape == (self.N, 4), f&#34;Quaternion sequence not of correct shape!\
                                {quaternion_seq.shape} instead of {(self.N, 4)}&#34;
        return quaternion_seq

    def as_euler(self) -&gt; np.ndarray:
        euler_seq = grid2euler(self.grid)
        assert isinstance(euler_seq, np.ndarray), &#34;An Euler sequence must be a numpy array!&#34;
        assert euler_seq.shape == (self.N, 3), f&#34;An Euler sequence not of correct shape!\
                                {euler_seq.shape} instead of {(self.N, 3)}&#34;
        return euler_seq

    def save_grid(self):
        np.save(f&#34;{PATH_OUTPUT_ROTGRIDS}{self.standard_name}.{ENDING_GRID_FILES}&#34;, self.grid)

    def save_grid_txt(self):
        np.savetxt(f&#34;{PATH_OUTPUT_ROTGRIDS}{self.standard_name}.txt&#34;, self.grid)

    def save_statistics(self, num_random: int = 100, print_message=False, alphas=None):
        if alphas is None:
            alphas = [pi / 6, 2 * pi / 6, 3 * pi / 6, 4 * pi / 6, 5 * pi / 6]
        # first message (what measure you are using)
        newline = &#34;\n&#34;
        m1 = f&#34;STATISTICS: Testing the coverage of grid {self.standard_name} using {num_random} &#34; \
             f&#34;random points on a sphere.&#34;
        m2 = f&#34;We select {num_random} random axes and count the number of grid points that fall within the angle&#34; \
             f&#34;alpha (selected from [pi / 6, 2 * pi / 6, 3 * pi / 6, 4 * pi / 6, 5 * pi / 6]) of this axis. For an&#34; \
             f&#34;ideally uniform grid, we expect the ratio of num_within_alpha/total_num_points to equal the ratio&#34; \
             f&#34;area_of_alpha_spherical_cap/area_of_sphere, which we call ideal coverage.&#34;
        stat_data, full_data = self._generate_statistics(alphas, num_rand_points=num_random)
        if print_message:
            print(m1)
            print(stat_data)
        # dealing with the file
        with open(self.short_statistics_path, &#34;w&#34;) as f:
            f.writelines([m1, newline, newline, m2, newline, newline])
        stat_data.to_csv(self.short_statistics_path, mode=&#34;a&#34;)
        full_data.to_csv(self.statistics_path, mode=&#34;w&#34;)

    def _generate_statistics(self, alphas, num_rand_points: int = 100) -&gt; tuple:
        # write out short version (&#34;N points&#34;, &#34;min&#34;, &#34;max&#34;, &#34;average&#34;, &#34;SD&#34;
        columns = [&#34;alphas&#34;, &#34;ideal coverages&#34;, &#34;min coverage&#34;, &#34;avg coverage&#34;, &#34;max coverage&#34;, &#34;standard deviation&#34;]
        ratios_columns = [&#34;coverages&#34;, &#34;alphas&#34;, &#34;ideal coverage&#34;]
        ratios = [[], [], []]
        sphere_surface = 4 * pi
        data = np.zeros((len(alphas), 6))  # 5 data columns for: alpha, ideal coverage, min, max, average, sd
        for i, alpha in enumerate(alphas):
            cone_area = 2 * pi * (1-np.cos(alpha))
            ideal_coverage = cone_area / sphere_surface
            actual_coverages = random_axes_count_points(self.get_grid(), alpha, num_random_points=num_rand_points)
            ratios[0].extend(actual_coverages)
            ratios[1].extend([alpha]*num_rand_points)
            ratios[2].extend([ideal_coverage]*num_rand_points)
            data[i][0] = alpha
            data[i][1] = ideal_coverage
            data[i][2] = np.min(actual_coverages)
            data[i][3] = np.average(actual_coverages)
            data[i][4] = np.max(actual_coverages)
            data[i][5] = np.std(actual_coverages)
        alpha_df = pd.DataFrame(data=data, columns=columns)
        alpha_df = alpha_df.set_index(&#34;alphas&#34;)
        ratios_df = pd.DataFrame(data=np.array(ratios).T, columns=ratios_columns)
        return alpha_df, ratios_df


def order_grid_points(grid: np.ndarray, N: int, start_i: int = 1) -&gt; np.ndarray:
    &#34;&#34;&#34;
    You are provided with a (possibly) unordered grid and return a grid with N points ordered in such a way that
    these N points have the best possible coverage.

    Args:
        grid: grid, array of shape (L, 3) to be ordered where L should be &gt;= N
        N: number of grid points wished at the end
        start_i: from which index to start ordering (in case the first i elements already ordered)

    Returns:
        an array of shape (N, 3) ordered in such a way that these N points have the best possible coverage.
    &#34;&#34;&#34;
    if N &gt; len(grid):
        raise ValueError(f&#34;N&gt;len(grid)! Only {len(grid)} points can be returned!&#34;)
    for index in range(start_i, min(len(grid), N)):
        grid = select_next_gridpoint(grid, index)
    return grid[:N]


def project_grid_on_sphere(grid: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;
    A grid can be seen as a collection of vectors to gridpoints. If a vector is scaled to 1, it will represent a point
    on a unit sphere in d-1 dimensions. This function normalizes the vectors, creating vectors pointing to the
    surface of a d-1 dimensional sphere.

    Args:
        grid: a (N, d) array where each row represents the coordinates of a grid point

    Returns:
        a (N, d) array where each row has been scaled to length 1
    &#34;&#34;&#34;
    assert isinstance(grid, np.ndarray), &#34;Grid must be a numpy array!&#34;
    assert len(grid.shape) == 2, &#34;Grid must have exactly two dimensions of shape: (num of points, num of dimensions)&#34;
    assert not np.any(np.all(np.isclose(grid, 0), axis=1)), &#34;There is a row with length zero, cannot normalise.&#34;
    largest_abs = np.max(np.abs(grid), axis=1)[:, np.newaxis]
    grid = np.divide(grid, largest_abs)
    norms = np.linalg.norm(grid, axis=1)[:, np.newaxis]
    return np.divide(grid, norms)


def select_next_gridpoint(set_grid_points, i):
    &#34;&#34;&#34;
    Provide a set of grid points where the first i are already sorted. Find the best next gridpoint out of points
    in set_grid_points[i:]

    Args:
        set_grid_points: grid, array of shape (L, 3) where elements up to i are already ordered
        i: index how far the array is already ordered (up to bun not including i).

    Returns:
        set_grid_points where the ith element in swapped with the best possible next grid point
    &#34;&#34;&#34;
    distances = cdist(set_grid_points[i:], set_grid_points[:i], metric=&#34;cosine&#34;)
    distances.sort()
    nn_dist = distances[:, 0]
    index_max = np.argmax(nn_dist)
    set_grid_points[[i, i + index_max]] = set_grid_points[[i + index_max, i]]
    return set_grid_points


class ZeroGrid(Grid):
    &#34;&#34;&#34;
    Use this rotation grid if you want no rotations at all. Consists of only one point, a nit vector in z-direction.
    &#34;&#34;&#34;

    def __init__(self, N=1, **kwargs):
        super().__init__(N, gen_alg=&#34;zero&#34;, **kwargs)
        self.standard_name = &#34;zero&#34;

    def generate_grid(self):
        self.grid = np.array([[0, 0, 1]])


class RandomQGrid(Grid):

    def __init__(self, N: int, **kwargs):
        super().__init__(N, gen_alg=&#34;randomQ&#34;, **kwargs)

    def generate_grid(self):
        result = np.zeros((self.N, 4))
        random_num = self.rn_gen.random((self.N, 3))
        result[:, 0] = np.sqrt(1 - random_num[:, 0]) * np.sin(2 * pi * random_num[:, 1])
        result[:, 1] = np.sqrt(1 - random_num[:, 0]) * np.cos(2 * pi * random_num[:, 1])
        result[:, 2] = np.sqrt(random_num[:, 0]) * np.sin(2 * pi * random_num[:, 2])
        result[:, 3] = np.sqrt(random_num[:, 0]) * np.cos(2 * pi * random_num[:, 2])
        self.grid = quaternion2grid(result)
        # No super call because ordering not needed for random points and the number of points is exact!


class RandomEGrid(Grid):

    def __init__(self, N: int, **kwargs):
        super().__init__(N, gen_alg=&#34;randomE&#34;, **kwargs)

    def generate_grid(self):
        euler_angles = 2 * pi * self.rn_gen.random((self.N, 3))
        self.grid = euler2grid(euler_angles)
        # No super call because ordering not needed for random points and the number of points is exact!


class SystemEGrid(Grid):

    def __init__(self, N: int, **kwargs):
        super().__init__(N, gen_alg=&#34;systemE&#34;, **kwargs)

    def generate_grid(self):
        self.grid = []
        num_points = 1
        while len(self.grid) &lt; self.N:
            phis = np.linspace(0, 2 * pi, num_points)
            thetas = np.linspace(0, 2 * pi, num_points)
            psis = np.linspace(0, 2 * pi, num_points)
            euler_meshgrid = np.array(np.meshgrid(*(phis, thetas, psis)), dtype=float)
            euler_meshgrid = euler_meshgrid.reshape((3, -1)).T
            # convert to a grid
            self.grid = euler2grid(euler_meshgrid)
            self.grid = np.unique(np.round(self.grid, UNIQUE_TOL), axis=0)
            num_points += 1
        super().generate_grid()


class Cube4DGrid(Grid):

    def __init__(self, N: int, **kwargs):
        self.d = 4  # dimensions
        super().__init__(N, gen_alg=&#34;cube4D&#34;, **kwargs)

    def generate_grid(self):
        self.grid = []
        num_divisions = 1
        state_before = np.random.get_state()
        while len(self.grid) &lt; self.N:
            grid_qua = self._full_d_dim_grid()
            grid_qua = self._select_only_faces(grid_qua)
            grid_qua = project_grid_on_sphere(grid_qua)
            # select only half the sphere
            grid_qua = grid_qua[grid_qua[:, self.d - 1] &gt;= 0, :]
            # convert to grid
            self.grid = quaternion2grid(grid_qua)
            self.grid = np.unique(np.round(self.grid, UNIQUE_TOL), axis=0)
            num_divisions += 1
        np.random.set_state(state_before)
        super().generate_grid()

    def _full_d_dim_grid(self, dtype=np.float64) -&gt; np.ndarray:
        &#34;&#34;&#34;
        This is a function to create a classical grid of a d-dimensional cube. It creates a grid over the entire
        (hyper)volume of the (hyper)cube.

        This is a unit cube between -sqrt(1/d) and sqrt(1/d) in all dimensions where d = num of dimensions.

        Args:
            dtype: forwarded to linspace while creating a grid

        Returns:
            a meshgrid of dimension (d, n, n, .... n) where n is repeated d times
        &#34;&#34;&#34;
        side = np.linspace(-1, 1, self.N, dtype=dtype)
        # repeat the same n points d times and then make a new line of the array every d elements
        sides = np.tile(side, self.d)
        sides = sides[np.newaxis, :].reshape((self.d, self.N))
        # create a grid by meshing every line of the sides array
        return np.array(np.meshgrid(*sides))

    def _select_only_faces(self, grid: np.ndarray):
        &#34;&#34;&#34;
        Take a meshgrid (d, n, n, ... n)  and return an array of points (N, d) including only the points that
        lie on the faces of the grid, so the edge points in at least one of dimensions.

        Args:
            grid: numpy array (d, n, n, ... n) containing grid points

        Returns:
            points (N, d) where N is the number of edge points and d the dimension
        &#34;&#34;&#34;
        assert self.d == len(grid)
        set_grids = []
        for swap_i in range(self.d):
            meshgrid_swapped = np.swapaxes(grid, axis1=1, axis2=(1 + swap_i))
            set_grids.append(meshgrid_swapped[:, 0, ...])
            set_grids.append(meshgrid_swapped[:, -1, ...])

        result = np.hstack(set_grids).reshape((self.d, -1)).T
        return np.unique(result, axis=0)


class Polyhedron3DGrid(Grid):

    def __init__(self, N: int, polyhedron, **kwargs):
        self.polyhedron = polyhedron()
        super().__init__(N, **kwargs)

    def generate_grid(self):
        while self.polyhedron.G.number_of_nodes() &lt; self.N:
            self.polyhedron.divide_edges()
        self.grid = np.array([y[&#34;projection&#34;] for x, y in self.polyhedron.G.nodes(data=True)]).squeeze()
        np.random.shuffle(self.grid)
        super().generate_grid()


class Cube3DGrid(Polyhedron3DGrid):

    def __init__(self, N: int, **kwargs):
        super().__init__(N, polyhedron=CubePolytope, gen_alg=&#34;cube3D&#34;, **kwargs)


class IcoGrid(Polyhedron3DGrid):

    def __init__(self, N: int, **kwargs):
        super().__init__(N, polyhedron=IcosahedronPolytope, gen_alg=&#34;ico&#34;, **kwargs)


class FullGrid:

    def __init__(self, b_grid: Grid, o_grid: Grid, t_grid: TranslationParser):
        &#34;&#34;&#34;
        In preparation. A combination object that enables work with a set of grids.

        Args:
            b_grid: body rotation grid
            o_grid: origin rotation grid
            t_grid: translation grid
        &#34;&#34;&#34;
        self.b_grid = b_grid
        self.o_grid = o_grid
        self.t_grid = t_grid

    def get_full_grid_name(self):
        nap = NameParser({&#34;o_grid&#34;: self.o_grid.standard_name, &#34;b_grid&#34;: self.b_grid.standard_name,
                          &#34;t_grid&#34;: self.t_grid.grid_hash})
        return nap.get_standard_name()


def build_grid(grid_type: str, N: int, **kwargs) -&gt; Grid:
    name2grid = {&#34;randomQ&#34;: RandomQGrid,
                 &#34;randomE&#34;: RandomEGrid,
                 &#34;cube4D&#34;: Cube4DGrid,
                 &#34;systemE&#34;: SystemEGrid,
                 &#34;cube3D&#34;: Cube3DGrid,
                 &#34;ico&#34;: IcoGrid,
                 &#34;zero&#34;: ZeroGrid}
    if grid_type not in name2grid.keys():
        raise ValueError(f&#34;{grid_type} is not a valid grid type. Try &#39;ico&#39;, &#39;cube3D&#39; ...&#34;)
    assert isinstance(N, int), &#34;Number of grid points must be an integer.&#34;
    assert N &gt;= 0, f&#34;Number of grid points cannot be negative, currently N={N}&#34;
    grid_obj = name2grid[grid_type]
    return grid_obj(N, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="molgri.grids.build_grid"><code class="name flex">
<span>def <span class="ident">build_grid</span></span>(<span>grid_type: str, N: int, **kwargs) ‑> <a title="molgri.grids.Grid" href="#molgri.grids.Grid">Grid</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_grid(grid_type: str, N: int, **kwargs) -&gt; Grid:
    name2grid = {&#34;randomQ&#34;: RandomQGrid,
                 &#34;randomE&#34;: RandomEGrid,
                 &#34;cube4D&#34;: Cube4DGrid,
                 &#34;systemE&#34;: SystemEGrid,
                 &#34;cube3D&#34;: Cube3DGrid,
                 &#34;ico&#34;: IcoGrid,
                 &#34;zero&#34;: ZeroGrid}
    if grid_type not in name2grid.keys():
        raise ValueError(f&#34;{grid_type} is not a valid grid type. Try &#39;ico&#39;, &#39;cube3D&#39; ...&#34;)
    assert isinstance(N, int), &#34;Number of grid points must be an integer.&#34;
    assert N &gt;= 0, f&#34;Number of grid points cannot be negative, currently N={N}&#34;
    grid_obj = name2grid[grid_type]
    return grid_obj(N, **kwargs)</code></pre>
</details>
</dd>
<dt id="molgri.grids.order_grid_points"><code class="name flex">
<span>def <span class="ident">order_grid_points</span></span>(<span>grid: numpy.ndarray, N: int, start_i: int = 1) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>You are provided with a (possibly) unordered grid and return a grid with N points ordered in such a way that
these N points have the best possible coverage.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid</code></strong></dt>
<dd>grid, array of shape (L, 3) to be ordered where L should be &gt;= N</dd>
<dt><strong><code>N</code></strong></dt>
<dd>number of grid points wished at the end</dd>
<dt><strong><code>start_i</code></strong></dt>
<dd>from which index to start ordering (in case the first i elements already ordered)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>an array of shape (N, 3) ordered in such a way that these N points have the best possible coverage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_grid_points(grid: np.ndarray, N: int, start_i: int = 1) -&gt; np.ndarray:
    &#34;&#34;&#34;
    You are provided with a (possibly) unordered grid and return a grid with N points ordered in such a way that
    these N points have the best possible coverage.

    Args:
        grid: grid, array of shape (L, 3) to be ordered where L should be &gt;= N
        N: number of grid points wished at the end
        start_i: from which index to start ordering (in case the first i elements already ordered)

    Returns:
        an array of shape (N, 3) ordered in such a way that these N points have the best possible coverage.
    &#34;&#34;&#34;
    if N &gt; len(grid):
        raise ValueError(f&#34;N&gt;len(grid)! Only {len(grid)} points can be returned!&#34;)
    for index in range(start_i, min(len(grid), N)):
        grid = select_next_gridpoint(grid, index)
    return grid[:N]</code></pre>
</details>
</dd>
<dt id="molgri.grids.project_grid_on_sphere"><code class="name flex">
<span>def <span class="ident">project_grid_on_sphere</span></span>(<span>grid: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>A grid can be seen as a collection of vectors to gridpoints. If a vector is scaled to 1, it will represent a point
on a unit sphere in d-1 dimensions. This function normalizes the vectors, creating vectors pointing to the
surface of a d-1 dimensional sphere.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grid</code></strong></dt>
<dd>a (N, d) array where each row represents the coordinates of a grid point</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a (N, d) array where each row has been scaled to length 1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def project_grid_on_sphere(grid: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;
    A grid can be seen as a collection of vectors to gridpoints. If a vector is scaled to 1, it will represent a point
    on a unit sphere in d-1 dimensions. This function normalizes the vectors, creating vectors pointing to the
    surface of a d-1 dimensional sphere.

    Args:
        grid: a (N, d) array where each row represents the coordinates of a grid point

    Returns:
        a (N, d) array where each row has been scaled to length 1
    &#34;&#34;&#34;
    assert isinstance(grid, np.ndarray), &#34;Grid must be a numpy array!&#34;
    assert len(grid.shape) == 2, &#34;Grid must have exactly two dimensions of shape: (num of points, num of dimensions)&#34;
    assert not np.any(np.all(np.isclose(grid, 0), axis=1)), &#34;There is a row with length zero, cannot normalise.&#34;
    largest_abs = np.max(np.abs(grid), axis=1)[:, np.newaxis]
    grid = np.divide(grid, largest_abs)
    norms = np.linalg.norm(grid, axis=1)[:, np.newaxis]
    return np.divide(grid, norms)</code></pre>
</details>
</dd>
<dt id="molgri.grids.second_neighbours"><code class="name flex">
<span>def <span class="ident">second_neighbours</span></span>(<span>graph: networkx.classes.graph.Graph, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Yield second neighbors of node in graph. Ignore second neighbours that are also first neighbours.
Second neighbors may repeat!</p>
<h2 id="example">Example</h2>
<p>5------6
|
|
2 ---- 1 ---- 3 ---- 7
|
|
--8&ndash;/</p>
<p>First neighbours of 1: 2, 6, 3, 8
Second neighbours of 1: 5, 7</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def second_neighbours(graph: nx.Graph, node):
    &#34;&#34;&#34;Yield second neighbors of node in graph. Ignore second neighbours that are also first neighbours.
    Second neighbors may repeat!

    Example:

        5------6
        |      |
        2 ---- 1 ---- 3 ---- 7
               |      |
               \--8--/

    First neighbours of 1: 2, 6, 3, 8
    Second neighbours of 1: 5, 7
    &#34;&#34;&#34;
    direct_neighbours = list(graph.neighbors(node))
    for neighbor_list in [graph.neighbors(n) for n in direct_neighbours]:
        for n in neighbor_list:
            if n != node and n not in direct_neighbours:
                yield n</code></pre>
</details>
</dd>
<dt id="molgri.grids.select_next_gridpoint"><code class="name flex">
<span>def <span class="ident">select_next_gridpoint</span></span>(<span>set_grid_points, i)</span>
</code></dt>
<dd>
<div class="desc"><p>Provide a set of grid points where the first i are already sorted. Find the best next gridpoint out of points
in set_grid_points[i:]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>set_grid_points</code></strong></dt>
<dd>grid, array of shape (L, 3) where elements up to i are already ordered</dd>
<dt><strong><code>i</code></strong></dt>
<dd>index how far the array is already ordered (up to bun not including i).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>set_grid_points where the ith element in swapped with the best possible next grid point</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_next_gridpoint(set_grid_points, i):
    &#34;&#34;&#34;
    Provide a set of grid points where the first i are already sorted. Find the best next gridpoint out of points
    in set_grid_points[i:]

    Args:
        set_grid_points: grid, array of shape (L, 3) where elements up to i are already ordered
        i: index how far the array is already ordered (up to bun not including i).

    Returns:
        set_grid_points where the ith element in swapped with the best possible next grid point
    &#34;&#34;&#34;
    distances = cdist(set_grid_points[i:], set_grid_points[:i], metric=&#34;cosine&#34;)
    distances.sort()
    nn_dist = distances[:, 0]
    index_max = np.argmax(nn_dist)
    set_grid_points[[i, i + index_max]] = set_grid_points[[i + index_max, i]]
    return set_grid_points</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="molgri.grids.Cube3DGrid"><code class="flex name class">
<span>class <span class="ident">Cube3DGrid</span></span>
<span>(</span><span>N: int, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>Generate a grid with one of generation algorithms.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gen_alg</code></strong></dt>
<dd>MUST BE SET IN SUBCLASSES, algorithm name, see names given in SIX_METHOD_NAMES</dd>
<dt><strong><code>N</code></strong></dt>
<dd>number of grid points</dd>
<dt><strong><code>ordered</code></strong></dt>
<dd>if True order and truncate, else only truncate to N points</dd>
<dt><strong><code>use_saved</code></strong></dt>
<dd>if True use saved grids if available</dd>
<dt><strong><code>time_generation</code></strong></dt>
<dd>if True write out a message about time needed for generation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cube3DGrid(Polyhedron3DGrid):

    def __init__(self, N: int, **kwargs):
        super().__init__(N, polyhedron=CubePolytope, gen_alg=&#34;cube3D&#34;, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="molgri.grids.Polyhedron3DGrid" href="#molgri.grids.Polyhedron3DGrid">Polyhedron3DGrid</a></li>
<li><a title="molgri.grids.Grid" href="#molgri.grids.Grid">Grid</a></li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="molgri.grids.Cube4DGrid"><code class="flex name class">
<span>class <span class="ident">Cube4DGrid</span></span>
<span>(</span><span>N: int, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>Generate a grid with one of generation algorithms.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gen_alg</code></strong></dt>
<dd>MUST BE SET IN SUBCLASSES, algorithm name, see names given in SIX_METHOD_NAMES</dd>
<dt><strong><code>N</code></strong></dt>
<dd>number of grid points</dd>
<dt><strong><code>ordered</code></strong></dt>
<dd>if True order and truncate, else only truncate to N points</dd>
<dt><strong><code>use_saved</code></strong></dt>
<dd>if True use saved grids if available</dd>
<dt><strong><code>time_generation</code></strong></dt>
<dd>if True write out a message about time needed for generation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cube4DGrid(Grid):

    def __init__(self, N: int, **kwargs):
        self.d = 4  # dimensions
        super().__init__(N, gen_alg=&#34;cube4D&#34;, **kwargs)

    def generate_grid(self):
        self.grid = []
        num_divisions = 1
        state_before = np.random.get_state()
        while len(self.grid) &lt; self.N:
            grid_qua = self._full_d_dim_grid()
            grid_qua = self._select_only_faces(grid_qua)
            grid_qua = project_grid_on_sphere(grid_qua)
            # select only half the sphere
            grid_qua = grid_qua[grid_qua[:, self.d - 1] &gt;= 0, :]
            # convert to grid
            self.grid = quaternion2grid(grid_qua)
            self.grid = np.unique(np.round(self.grid, UNIQUE_TOL), axis=0)
            num_divisions += 1
        np.random.set_state(state_before)
        super().generate_grid()

    def _full_d_dim_grid(self, dtype=np.float64) -&gt; np.ndarray:
        &#34;&#34;&#34;
        This is a function to create a classical grid of a d-dimensional cube. It creates a grid over the entire
        (hyper)volume of the (hyper)cube.

        This is a unit cube between -sqrt(1/d) and sqrt(1/d) in all dimensions where d = num of dimensions.

        Args:
            dtype: forwarded to linspace while creating a grid

        Returns:
            a meshgrid of dimension (d, n, n, .... n) where n is repeated d times
        &#34;&#34;&#34;
        side = np.linspace(-1, 1, self.N, dtype=dtype)
        # repeat the same n points d times and then make a new line of the array every d elements
        sides = np.tile(side, self.d)
        sides = sides[np.newaxis, :].reshape((self.d, self.N))
        # create a grid by meshing every line of the sides array
        return np.array(np.meshgrid(*sides))

    def _select_only_faces(self, grid: np.ndarray):
        &#34;&#34;&#34;
        Take a meshgrid (d, n, n, ... n)  and return an array of points (N, d) including only the points that
        lie on the faces of the grid, so the edge points in at least one of dimensions.

        Args:
            grid: numpy array (d, n, n, ... n) containing grid points

        Returns:
            points (N, d) where N is the number of edge points and d the dimension
        &#34;&#34;&#34;
        assert self.d == len(grid)
        set_grids = []
        for swap_i in range(self.d):
            meshgrid_swapped = np.swapaxes(grid, axis1=1, axis2=(1 + swap_i))
            set_grids.append(meshgrid_swapped[:, 0, ...])
            set_grids.append(meshgrid_swapped[:, -1, ...])

        result = np.hstack(set_grids).reshape((self.d, -1)).T
        return np.unique(result, axis=0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="molgri.grids.Grid" href="#molgri.grids.Grid">Grid</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="molgri.grids.Cube4DGrid.generate_grid"><code class="name flex">
<span>def <span class="ident">generate_grid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_grid(self):
    self.grid = []
    num_divisions = 1
    state_before = np.random.get_state()
    while len(self.grid) &lt; self.N:
        grid_qua = self._full_d_dim_grid()
        grid_qua = self._select_only_faces(grid_qua)
        grid_qua = project_grid_on_sphere(grid_qua)
        # select only half the sphere
        grid_qua = grid_qua[grid_qua[:, self.d - 1] &gt;= 0, :]
        # convert to grid
        self.grid = quaternion2grid(grid_qua)
        self.grid = np.unique(np.round(self.grid, UNIQUE_TOL), axis=0)
        num_divisions += 1
    np.random.set_state(state_before)
    super().generate_grid()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="molgri.grids.CubePolytope"><code class="flex name class">
<span>class <span class="ident">CubePolytope</span></span>
</code></dt>
<dd>
<div class="desc"><p>CubeGrid is a graph object, its central feature is self.G (networkx graph). In the beginning, each node is
a vertex of a 3D cube. It is possible to subdivide the sides, in that case a new point always appears in the
middle of a square and half of previous sides.</p>
<p>A polytope is a 3-dim object consisting of a set of vertices and connections between them (edges) saved
in self.G property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CubePolytope(Polytope):
    &#34;&#34;&#34;
    CubeGrid is a graph object, its central feature is self.G (networkx graph). In the beginning, each node is
    a vertex of a 3D cube. It is possible to subdivide the sides, in that case a new point always appears in the
    middle of a square and half of previous sides.
    &#34;&#34;&#34;

    def _create_level0(self):
        # DO NOT change order of points - faces will be wrong!
        # each face contains numbers - indices of vertices that border on this face
        self.faces = [[0, 1, 2, 4],
                      [0, 2, 3, 6],
                      [0, 1, 3, 5],
                      [3, 5, 6, 7],
                      [1, 4, 5, 7],
                      [2, 4, 6, 7]]
        self.side_len = 2 * np.sqrt(1/3)
        # create vertices
        vertices = [(-self.side_len/2, -self.side_len/2, -self.side_len/2),
                    (-self.side_len/2, -self.side_len/2, self.side_len/2),
                    (-self.side_len/2, self.side_len/2, -self.side_len/2),
                    (self.side_len/2, -self.side_len/2, -self.side_len/2),
                    (-self.side_len/2, self.side_len/2, self.side_len/2),
                    (self.side_len/2, -self.side_len/2, self.side_len/2),
                    (self.side_len/2, self.side_len/2, -self.side_len/2),
                    (self.side_len/2, self.side_len/2, self.side_len/2)]
        vertices = np.array(vertices)
        # create edges
        point_connections = _calc_edges(vertices, self.side_len)
        # add vertices and edges to the graph
        for i, vert in enumerate(vertices):
            set_of_faces = tuple(faces_i for faces_i, face in enumerate(self.faces) if i in face)
            self.G.add_node(tuple(vert), level=self.current_level, face=set_of_faces,
                            projection=project_grid_on_sphere(vert[np.newaxis, :]))
        for key, value in point_connections.items():
            for vi in value:
                self.G.add_edge(key, tuple(vi),
                                length=dist_on_sphere(self.G.nodes[key][&#34;projection&#34;],
                                                      self.G.nodes[tuple(vi)][&#34;projection&#34;]))
        # just to check ...
        assert self.G.number_of_nodes() == 8
        assert self.G.number_of_edges() == 24
        for node in self.G.nodes(data=True):
            assert len(node[1][&#34;face&#34;]) == 3 and node[1][&#34;level&#34;] == 0
        self.side_len = self.side_len / 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="molgri.grids.Polytope" href="#molgri.grids.Polytope">Polytope</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="molgri.grids.Polytope" href="#molgri.grids.Polytope">Polytope</a></b></code>:
<ul class="hlist">
<li><code><a title="molgri.grids.Polytope.divide_edges" href="#molgri.grids.Polytope.divide_edges">divide_edges</a></code></li>
<li><code><a title="molgri.grids.Polytope.plot_edges" href="#molgri.grids.Polytope.plot_edges">plot_edges</a></code></li>
<li><code><a title="molgri.grids.Polytope.plot_graph" href="#molgri.grids.Polytope.plot_graph">plot_graph</a></code></li>
<li><code><a title="molgri.grids.Polytope.plot_points" href="#molgri.grids.Polytope.plot_points">plot_points</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="molgri.grids.FullGrid"><code class="flex name class">
<span>class <span class="ident">FullGrid</span></span>
<span>(</span><span>b_grid: <a title="molgri.grids.Grid" href="#molgri.grids.Grid">Grid</a>, o_grid: <a title="molgri.grids.Grid" href="#molgri.grids.Grid">Grid</a>, t_grid: <a title="molgri.parsers.TranslationParser" href="parsers.html#molgri.parsers.TranslationParser">TranslationParser</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>In preparation. A combination object that enables work with a set of grids.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>b_grid</code></strong></dt>
<dd>body rotation grid</dd>
<dt><strong><code>o_grid</code></strong></dt>
<dd>origin rotation grid</dd>
<dt><strong><code>t_grid</code></strong></dt>
<dd>translation grid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FullGrid:

    def __init__(self, b_grid: Grid, o_grid: Grid, t_grid: TranslationParser):
        &#34;&#34;&#34;
        In preparation. A combination object that enables work with a set of grids.

        Args:
            b_grid: body rotation grid
            o_grid: origin rotation grid
            t_grid: translation grid
        &#34;&#34;&#34;
        self.b_grid = b_grid
        self.o_grid = o_grid
        self.t_grid = t_grid

    def get_full_grid_name(self):
        nap = NameParser({&#34;o_grid&#34;: self.o_grid.standard_name, &#34;b_grid&#34;: self.b_grid.standard_name,
                          &#34;t_grid&#34;: self.t_grid.grid_hash})
        return nap.get_standard_name()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="molgri.grids.FullGrid.get_full_grid_name"><code class="name flex">
<span>def <span class="ident">get_full_grid_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_full_grid_name(self):
    nap = NameParser({&#34;o_grid&#34;: self.o_grid.standard_name, &#34;b_grid&#34;: self.b_grid.standard_name,
                      &#34;t_grid&#34;: self.t_grid.grid_hash})
    return nap.get_standard_name()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="molgri.grids.Grid"><code class="flex name class">
<span>class <span class="ident">Grid</span></span>
<span>(</span><span>N: int, *, ordered: bool = True, use_saved: bool = False, gen_alg: str = None, time_generation: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>Generate a grid with one of generation algorithms.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gen_alg</code></strong></dt>
<dd>MUST BE SET IN SUBCLASSES, algorithm name, see names given in SIX_METHOD_NAMES</dd>
<dt><strong><code>N</code></strong></dt>
<dd>number of grid points</dd>
<dt><strong><code>ordered</code></strong></dt>
<dd>if True order and truncate, else only truncate to N points</dd>
<dt><strong><code>use_saved</code></strong></dt>
<dd>if True use saved grids if available</dd>
<dt><strong><code>time_generation</code></strong></dt>
<dd>if True write out a message about time needed for generation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Grid(ABC):

    def __init__(self, N: int, *, ordered: bool = True, use_saved: bool = False, gen_alg: str = None,
                 time_generation: bool = False):
        &#34;&#34;&#34;
        Generate a grid with one of generation algorithms.

        Args:
            gen_alg: MUST BE SET IN SUBCLASSES, algorithm name, see names given in SIX_METHOD_NAMES
            N: number of grid points
            ordered: if True order and truncate, else only truncate to N points
            use_saved: if True use saved grids if available
            time_generation: if True write out a message about time needed for generation
        &#34;&#34;&#34;
        self.rn_gen = np.random.default_rng(DEFAULT_SEED)
        np.random.seed(DEFAULT_SEED)
        assert gen_alg in SIX_METHOD_NAMES or gen_alg == &#34;zero&#34;, f&#34;{gen_alg} is not a valid generation algorithm name&#34;
        self.ordered = ordered
        self.N = N
        name_properties = {&#34;grid_type&#34;: gen_alg, &#34;num_grid_points&#34;: N, &#34;ordering&#34;: ordered}
        self.standard_name = NameParser(name_properties).get_standard_name()
        self.decorator_label = f&#34;rotation grid {self.standard_name}&#34;
        self.grid = None
        self.time = 0
        self.nn_dist_arch = None
        self.nn_dist_cup = None
        self.short_statistics_path = f&#34;{PATH_OUTPUT_STAT}{self.standard_name}_short_stat.txt&#34;
        self.statistics_path = f&#34;{PATH_OUTPUT_STAT}{self.standard_name}_full_stat.csv&#34;
        gen_func = self.generate_and_time if time_generation else self.generate_grid
        # if this option enabled, search first if this grid has already been saved
        if use_saved:
            try:
                self.grid = np.load(f&#34;{PATH_OUTPUT_ROTGRIDS}{self.standard_name}.npy&#34;)
            except FileNotFoundError:
                gen_func()
                self.save_grid()
        else:
            gen_func()
        assert isinstance(self.grid, np.ndarray), &#34;A grid must be a numpy array!&#34;
        assert self.grid.shape == (N, 3), f&#34;Grid not of correct shape! {self.grid.shape} instead of {(N, 3)}&#34;
        assert np.allclose(np.linalg.norm(self.grid, axis=1), 1, atol=10**(-UNIQUE_TOL))

    def get_grid(self) -&gt; np.ndarray:
        return self.grid

    @abstractmethod
    def generate_grid(self):
        # order or truncate
        if self.ordered:
            self._order()
        else:
            self.grid = self.grid[:self.N]

    @time_method
    def generate_and_time(self):
        self.generate_grid()

    def _order(self):
        self.grid = order_grid_points(self.grid, self.N)

    def as_quaternion(self) -&gt; np.ndarray:
        quaternion_seq = grid2quaternion(self.grid)
        assert isinstance(quaternion_seq, np.ndarray), &#34;A quaternion sequence must be a numpy array!&#34;
        assert quaternion_seq.shape == (self.N, 4), f&#34;Quaternion sequence not of correct shape!\
                                {quaternion_seq.shape} instead of {(self.N, 4)}&#34;
        return quaternion_seq

    def as_euler(self) -&gt; np.ndarray:
        euler_seq = grid2euler(self.grid)
        assert isinstance(euler_seq, np.ndarray), &#34;An Euler sequence must be a numpy array!&#34;
        assert euler_seq.shape == (self.N, 3), f&#34;An Euler sequence not of correct shape!\
                                {euler_seq.shape} instead of {(self.N, 3)}&#34;
        return euler_seq

    def save_grid(self):
        np.save(f&#34;{PATH_OUTPUT_ROTGRIDS}{self.standard_name}.{ENDING_GRID_FILES}&#34;, self.grid)

    def save_grid_txt(self):
        np.savetxt(f&#34;{PATH_OUTPUT_ROTGRIDS}{self.standard_name}.txt&#34;, self.grid)

    def save_statistics(self, num_random: int = 100, print_message=False, alphas=None):
        if alphas is None:
            alphas = [pi / 6, 2 * pi / 6, 3 * pi / 6, 4 * pi / 6, 5 * pi / 6]
        # first message (what measure you are using)
        newline = &#34;\n&#34;
        m1 = f&#34;STATISTICS: Testing the coverage of grid {self.standard_name} using {num_random} &#34; \
             f&#34;random points on a sphere.&#34;
        m2 = f&#34;We select {num_random} random axes and count the number of grid points that fall within the angle&#34; \
             f&#34;alpha (selected from [pi / 6, 2 * pi / 6, 3 * pi / 6, 4 * pi / 6, 5 * pi / 6]) of this axis. For an&#34; \
             f&#34;ideally uniform grid, we expect the ratio of num_within_alpha/total_num_points to equal the ratio&#34; \
             f&#34;area_of_alpha_spherical_cap/area_of_sphere, which we call ideal coverage.&#34;
        stat_data, full_data = self._generate_statistics(alphas, num_rand_points=num_random)
        if print_message:
            print(m1)
            print(stat_data)
        # dealing with the file
        with open(self.short_statistics_path, &#34;w&#34;) as f:
            f.writelines([m1, newline, newline, m2, newline, newline])
        stat_data.to_csv(self.short_statistics_path, mode=&#34;a&#34;)
        full_data.to_csv(self.statistics_path, mode=&#34;w&#34;)

    def _generate_statistics(self, alphas, num_rand_points: int = 100) -&gt; tuple:
        # write out short version (&#34;N points&#34;, &#34;min&#34;, &#34;max&#34;, &#34;average&#34;, &#34;SD&#34;
        columns = [&#34;alphas&#34;, &#34;ideal coverages&#34;, &#34;min coverage&#34;, &#34;avg coverage&#34;, &#34;max coverage&#34;, &#34;standard deviation&#34;]
        ratios_columns = [&#34;coverages&#34;, &#34;alphas&#34;, &#34;ideal coverage&#34;]
        ratios = [[], [], []]
        sphere_surface = 4 * pi
        data = np.zeros((len(alphas), 6))  # 5 data columns for: alpha, ideal coverage, min, max, average, sd
        for i, alpha in enumerate(alphas):
            cone_area = 2 * pi * (1-np.cos(alpha))
            ideal_coverage = cone_area / sphere_surface
            actual_coverages = random_axes_count_points(self.get_grid(), alpha, num_random_points=num_rand_points)
            ratios[0].extend(actual_coverages)
            ratios[1].extend([alpha]*num_rand_points)
            ratios[2].extend([ideal_coverage]*num_rand_points)
            data[i][0] = alpha
            data[i][1] = ideal_coverage
            data[i][2] = np.min(actual_coverages)
            data[i][3] = np.average(actual_coverages)
            data[i][4] = np.max(actual_coverages)
            data[i][5] = np.std(actual_coverages)
        alpha_df = pd.DataFrame(data=data, columns=columns)
        alpha_df = alpha_df.set_index(&#34;alphas&#34;)
        ratios_df = pd.DataFrame(data=np.array(ratios).T, columns=ratios_columns)
        return alpha_df, ratios_df</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="molgri.grids.Cube4DGrid" href="#molgri.grids.Cube4DGrid">Cube4DGrid</a></li>
<li><a title="molgri.grids.Polyhedron3DGrid" href="#molgri.grids.Polyhedron3DGrid">Polyhedron3DGrid</a></li>
<li><a title="molgri.grids.RandomEGrid" href="#molgri.grids.RandomEGrid">RandomEGrid</a></li>
<li><a title="molgri.grids.RandomQGrid" href="#molgri.grids.RandomQGrid">RandomQGrid</a></li>
<li><a title="molgri.grids.SystemEGrid" href="#molgri.grids.SystemEGrid">SystemEGrid</a></li>
<li><a title="molgri.grids.ZeroGrid" href="#molgri.grids.ZeroGrid">ZeroGrid</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="molgri.grids.Grid.as_euler"><code class="name flex">
<span>def <span class="ident">as_euler</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_euler(self) -&gt; np.ndarray:
    euler_seq = grid2euler(self.grid)
    assert isinstance(euler_seq, np.ndarray), &#34;An Euler sequence must be a numpy array!&#34;
    assert euler_seq.shape == (self.N, 3), f&#34;An Euler sequence not of correct shape!\
                            {euler_seq.shape} instead of {(self.N, 3)}&#34;
    return euler_seq</code></pre>
</details>
</dd>
<dt id="molgri.grids.Grid.as_quaternion"><code class="name flex">
<span>def <span class="ident">as_quaternion</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_quaternion(self) -&gt; np.ndarray:
    quaternion_seq = grid2quaternion(self.grid)
    assert isinstance(quaternion_seq, np.ndarray), &#34;A quaternion sequence must be a numpy array!&#34;
    assert quaternion_seq.shape == (self.N, 4), f&#34;Quaternion sequence not of correct shape!\
                            {quaternion_seq.shape} instead of {(self.N, 4)}&#34;
    return quaternion_seq</code></pre>
</details>
</dd>
<dt id="molgri.grids.Grid.generate_and_time"><code class="name flex">
<span>def <span class="ident">generate_and_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@time_method
def generate_and_time(self):
    self.generate_grid()</code></pre>
</details>
</dd>
<dt id="molgri.grids.Grid.generate_grid"><code class="name flex">
<span>def <span class="ident">generate_grid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def generate_grid(self):
    # order or truncate
    if self.ordered:
        self._order()
    else:
        self.grid = self.grid[:self.N]</code></pre>
</details>
</dd>
<dt id="molgri.grids.Grid.get_grid"><code class="name flex">
<span>def <span class="ident">get_grid</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_grid(self) -&gt; np.ndarray:
    return self.grid</code></pre>
</details>
</dd>
<dt id="molgri.grids.Grid.save_grid"><code class="name flex">
<span>def <span class="ident">save_grid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_grid(self):
    np.save(f&#34;{PATH_OUTPUT_ROTGRIDS}{self.standard_name}.{ENDING_GRID_FILES}&#34;, self.grid)</code></pre>
</details>
</dd>
<dt id="molgri.grids.Grid.save_grid_txt"><code class="name flex">
<span>def <span class="ident">save_grid_txt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_grid_txt(self):
    np.savetxt(f&#34;{PATH_OUTPUT_ROTGRIDS}{self.standard_name}.txt&#34;, self.grid)</code></pre>
</details>
</dd>
<dt id="molgri.grids.Grid.save_statistics"><code class="name flex">
<span>def <span class="ident">save_statistics</span></span>(<span>self, num_random: int = 100, print_message=False, alphas=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_statistics(self, num_random: int = 100, print_message=False, alphas=None):
    if alphas is None:
        alphas = [pi / 6, 2 * pi / 6, 3 * pi / 6, 4 * pi / 6, 5 * pi / 6]
    # first message (what measure you are using)
    newline = &#34;\n&#34;
    m1 = f&#34;STATISTICS: Testing the coverage of grid {self.standard_name} using {num_random} &#34; \
         f&#34;random points on a sphere.&#34;
    m2 = f&#34;We select {num_random} random axes and count the number of grid points that fall within the angle&#34; \
         f&#34;alpha (selected from [pi / 6, 2 * pi / 6, 3 * pi / 6, 4 * pi / 6, 5 * pi / 6]) of this axis. For an&#34; \
         f&#34;ideally uniform grid, we expect the ratio of num_within_alpha/total_num_points to equal the ratio&#34; \
         f&#34;area_of_alpha_spherical_cap/area_of_sphere, which we call ideal coverage.&#34;
    stat_data, full_data = self._generate_statistics(alphas, num_rand_points=num_random)
    if print_message:
        print(m1)
        print(stat_data)
    # dealing with the file
    with open(self.short_statistics_path, &#34;w&#34;) as f:
        f.writelines([m1, newline, newline, m2, newline, newline])
    stat_data.to_csv(self.short_statistics_path, mode=&#34;a&#34;)
    full_data.to_csv(self.statistics_path, mode=&#34;w&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="molgri.grids.IcoGrid"><code class="flex name class">
<span>class <span class="ident">IcoGrid</span></span>
<span>(</span><span>N: int, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>Generate a grid with one of generation algorithms.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gen_alg</code></strong></dt>
<dd>MUST BE SET IN SUBCLASSES, algorithm name, see names given in SIX_METHOD_NAMES</dd>
<dt><strong><code>N</code></strong></dt>
<dd>number of grid points</dd>
<dt><strong><code>ordered</code></strong></dt>
<dd>if True order and truncate, else only truncate to N points</dd>
<dt><strong><code>use_saved</code></strong></dt>
<dd>if True use saved grids if available</dd>
<dt><strong><code>time_generation</code></strong></dt>
<dd>if True write out a message about time needed for generation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IcoGrid(Polyhedron3DGrid):

    def __init__(self, N: int, **kwargs):
        super().__init__(N, polyhedron=IcosahedronPolytope, gen_alg=&#34;ico&#34;, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="molgri.grids.Polyhedron3DGrid" href="#molgri.grids.Polyhedron3DGrid">Polyhedron3DGrid</a></li>
<li><a title="molgri.grids.Grid" href="#molgri.grids.Grid">Grid</a></li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="molgri.grids.IcosahedronPolytope"><code class="flex name class">
<span>class <span class="ident">IcosahedronPolytope</span></span>
</code></dt>
<dd>
<div class="desc"><p>IcosahedronGrid is a graph object, its central feature is self.G (networkx graph). In the beginning, each node is
a vertex of a 3D icosahedron. It is possible to subdivide the sides, in that case a new point always appears in the
middle of each triangle side.</p>
<p>A polytope is a 3-dim object consisting of a set of vertices and connections between them (edges) saved
in self.G property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IcosahedronPolytope(Polytope):
    &#34;&#34;&#34;
    IcosahedronGrid is a graph object, its central feature is self.G (networkx graph). In the beginning, each node is
    a vertex of a 3D icosahedron. It is possible to subdivide the sides, in that case a new point always appears in the
    middle of each triangle side.
    &#34;&#34;&#34;

    def _create_level0(self):
        # DO NOT change order of points - faces will be wrong!
        # each face contains numbers - indices of vertices that border on this face
        self.faces = [[0, 11, 5],
                      [0, 5, 1],
                      [0, 1, 7],
                      [0, 7, 10],
                      [0, 10, 11],
                      [1, 5, 9],
                      [5, 11, 4],
                      [11, 10, 2],
                      [10, 7, 6],
                      [7, 1, 8],
                      [3, 9, 4],
                      [3, 4, 2],
                      [3, 2, 6],
                      [3, 6, 8],
                      [3, 8, 9],
                      [4, 9, 5],
                      [2, 4, 11],
                      [6, 2, 10],
                      [8, 6, 7],
                      [9, 8, 1]]
        side_len = 1 / np.sin(2 * pi / 5)
        self.side_len = side_len
        # create vertices
        vertices = [(-1, golden, 0), (1, golden, 0), (-1, -golden, 0), (1, -golden, 0),
                    (0, -1, golden), (0, 1, golden), (0, -1, -golden), (0, 1, -golden),
                    (golden, 0, -1), (golden, 0, 1), (-golden, 0, -1), (-golden, 0, 1)]
        vertices = np.array(vertices) * side_len / 2
        # create edges
        point_connections = _calc_edges(vertices, side_len)
        # add vertices and edges to the graph
        for i, vert in enumerate(vertices):
            set_of_faces = tuple(faces_i for faces_i, face in enumerate(self.faces) if i in face)
            self.G.add_node(tuple(vert), level=self.current_level, face=set_of_faces,
                            projection=project_grid_on_sphere(vert[np.newaxis, :]))
        for key, value in point_connections.items():
            for vi in value:
                self.G.add_edge(key, tuple(vi),
                                length=dist_on_sphere(self.G.nodes[key][&#34;projection&#34;],
                                                      self.G.nodes[tuple(vi)][&#34;projection&#34;]))
        # just to check ...
        assert self.G.number_of_nodes() == 12
        assert self.G.number_of_edges() == 30
        for node in self.G.nodes(data=True):
            assert len(node[1][&#34;face&#34;]) == 5 and node[1][&#34;level&#34;] == 0
        self.side_len = side_len / 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="molgri.grids.Polytope" href="#molgri.grids.Polytope">Polytope</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="molgri.grids.Polytope" href="#molgri.grids.Polytope">Polytope</a></b></code>:
<ul class="hlist">
<li><code><a title="molgri.grids.Polytope.divide_edges" href="#molgri.grids.Polytope.divide_edges">divide_edges</a></code></li>
<li><code><a title="molgri.grids.Polytope.plot_edges" href="#molgri.grids.Polytope.plot_edges">plot_edges</a></code></li>
<li><code><a title="molgri.grids.Polytope.plot_graph" href="#molgri.grids.Polytope.plot_graph">plot_graph</a></code></li>
<li><code><a title="molgri.grids.Polytope.plot_points" href="#molgri.grids.Polytope.plot_points">plot_points</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="molgri.grids.Polyhedron3DGrid"><code class="flex name class">
<span>class <span class="ident">Polyhedron3DGrid</span></span>
<span>(</span><span>N: int, polyhedron, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>Generate a grid with one of generation algorithms.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gen_alg</code></strong></dt>
<dd>MUST BE SET IN SUBCLASSES, algorithm name, see names given in SIX_METHOD_NAMES</dd>
<dt><strong><code>N</code></strong></dt>
<dd>number of grid points</dd>
<dt><strong><code>ordered</code></strong></dt>
<dd>if True order and truncate, else only truncate to N points</dd>
<dt><strong><code>use_saved</code></strong></dt>
<dd>if True use saved grids if available</dd>
<dt><strong><code>time_generation</code></strong></dt>
<dd>if True write out a message about time needed for generation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Polyhedron3DGrid(Grid):

    def __init__(self, N: int, polyhedron, **kwargs):
        self.polyhedron = polyhedron()
        super().__init__(N, **kwargs)

    def generate_grid(self):
        while self.polyhedron.G.number_of_nodes() &lt; self.N:
            self.polyhedron.divide_edges()
        self.grid = np.array([y[&#34;projection&#34;] for x, y in self.polyhedron.G.nodes(data=True)]).squeeze()
        np.random.shuffle(self.grid)
        super().generate_grid()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="molgri.grids.Grid" href="#molgri.grids.Grid">Grid</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="molgri.grids.Cube3DGrid" href="#molgri.grids.Cube3DGrid">Cube3DGrid</a></li>
<li><a title="molgri.grids.IcoGrid" href="#molgri.grids.IcoGrid">IcoGrid</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="molgri.grids.Polyhedron3DGrid.generate_grid"><code class="name flex">
<span>def <span class="ident">generate_grid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_grid(self):
    while self.polyhedron.G.number_of_nodes() &lt; self.N:
        self.polyhedron.divide_edges()
    self.grid = np.array([y[&#34;projection&#34;] for x, y in self.polyhedron.G.nodes(data=True)]).squeeze()
    np.random.shuffle(self.grid)
    super().generate_grid()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="molgri.grids.Polytope"><code class="flex name class">
<span>class <span class="ident">Polytope</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>A polytope is a 3-dim object consisting of a set of vertices and connections between them (edges) saved
in self.G property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Polytope(ABC):

    def __init__(self):
        &#34;&#34;&#34;
        A polytope is a 3-dim object consisting of a set of vertices and connections between them (edges) saved
        in self.G property.
        &#34;&#34;&#34;
        self.G = nx.Graph()
        self.faces = []
        self.current_level = 0
        self.side_len = 0
        self._create_level0()

    @abstractmethod
    def _create_level0(self):
        &#34;&#34;&#34;This is implemented by each subclass since they have different edges, vertices and faces&#34;&#34;&#34;

    def plot_graph(self):
        &#34;&#34;&#34;
        Plot the networkx graph of self.G.
        &#34;&#34;&#34;
        node_labels = {i: tuple(np.round(i, 3)) for i in self.G.nodes}
        nx.draw_networkx(self.G, pos=nx.circular_layout(self.G), with_labels=True, labels=node_labels)

    def plot_points(self, ax, select_faces: set = None, projection: bool = False):
        &#34;&#34;&#34;
        Plot the points of the icosahedron + possible division points. Colored by level at which the point was added.
        Possible to select only one or a few faces on which points are to be plotted for clarity.

        Args:
            ax: axis
            select_faces: a set of face numbers from 0 to (incl) 19, e.g. {0, 5}. If None, all faces are shown.
            projection: True if you want to plot the projected points, not the ones on surfaces of polytope
        &#34;&#34;&#34;
        select_faces = set(range(20)) if select_faces is None else select_faces
        level_color = [&#34;black&#34;, &#34;red&#34;, &#34;blue&#34;, &#34;green&#34;]
        for point in self.G.nodes(data=True):
            # select only points that belong to at least one of the chosen select_faces
            if len(set(point[1][&#34;face&#34;]).intersection(select_faces)) &gt; 0:
                # color selected based on the level of the node
                level_node = point[1][&#34;level&#34;]
                if projection:
                    proj_node = point[1][&#34;projection&#34;]
                    ax.scatter(*proj_node[0], color=level_color[level_node], s=30)
                else:
                    ax.scatter(*point[0], color=level_color[level_node], s=30)

    def plot_edges(self, ax, select_faces=None, **kwargs):
        &#34;&#34;&#34;
        Plot the edges between the points. Can select to display only some faces for clarity.

        Args:
            ax: axis
            select_faces: a set of face numbers from 0 to (incl) 19, e.g. {0, 5}. If None, all faces are shown.
            **kwargs: other plotting arguments
        &#34;&#34;&#34;
        select_faces = set(range(20)) if select_faces is None else select_faces
        for edge in self.G.edges:
            faces_edge_1 = set(self.G.nodes[edge[0]][&#34;face&#34;])
            faces_edge_2 = set(self.G.nodes[edge[1]][&#34;face&#34;])
            # both the start and the end point of the edge must belong to one of the selected faces
            if len(faces_edge_1.intersection(select_faces)) &gt; 0 and len(faces_edge_2.intersection(select_faces)) &gt; 0:
                ax.plot(*np.array(edge).T, color=&#34;black&#34;,  **kwargs)

    def divide_edges(self):
        &#34;&#34;&#34;
        Subdivide once. If previous faces are triangles, adds three points per face (half sides). If they are
        squares, adds 4 points per face (half sides + middle). New points will have a higher level and will
        be appropriately added to one or more faces (if on edges).
        &#34;&#34;&#34;
        # need to keep track of what to add/remove, since we can&#39;t change the network while inside the loop
        # consists of (new_point, previous_point_1, previous_point_2) to keep all info
        nodes_to_add = []
        for node_vector in self.G.nodes():
            for neighbour_vector in self.G.neighbors(node_vector):
                # this is just to avoid doing everything twice - do it for edge A-B but not B-A
                if node_vector &lt; neighbour_vector:
                    # new point is just the average of the previous two
                    new_point = tuple((np.array(node_vector)+np.array(neighbour_vector))/2.0)
                    nodes_to_add.append((new_point, node_vector, neighbour_vector))
        # add new nodes, add edges from cont. points to the node and delete the edge between the cont. points
        for el in nodes_to_add:
            new_point, node_vector, neighbour_vector = el
            # new point will have the set of faces that both node and neighbour vector have
            faces_node_vector = self.G.nodes[node_vector][&#34;face&#34;]
            faces_neighbour_vector = self.G.nodes[neighbour_vector][&#34;face&#34;]
            # diagonals get added twice, so this is necessary
            if new_point not in self.G.nodes:
                self.G.add_node(new_point, level=self.current_level + 1,
                                face=set(faces_node_vector).intersection(faces_neighbour_vector),
                                projection=project_grid_on_sphere(np.array(new_point)[np.newaxis, :]))
            self.G.add_edge(new_point, neighbour_vector,
                            length=dist_on_sphere(self.G.nodes[new_point][&#34;projection&#34;],
                                                  self.G.nodes[neighbour_vector][&#34;projection&#34;]))
            self.G.add_edge(new_point, node_vector,
                            length=dist_on_sphere(self.G.nodes[new_point][&#34;projection&#34;],
                                                  self.G.nodes[neighbour_vector][&#34;projection&#34;]))
            # self.G.remove_edge(node_vector, neighbour_vector)
        # also add edges between new nodes at distance side_len or sqrt(2)*side_len
        new_level = [x for x, y in self.G.nodes(data=True) if y[&#39;level&#39;] == self.current_level+1]
        for new_node in new_level:
            # searching only second neighbours at appropriate level
            sec_neighbours = list(second_neighbours(self.G, new_node))
            sec_neighbours = [x for x in sec_neighbours if self.G.nodes[x][&#34;level&#34;] == self.current_level+1]
            for other_node in sec_neighbours:
                node_dist = np.linalg.norm(np.array(new_node)-np.array(other_node))
                # check distance criterion
                if np.isclose(node_dist, self.side_len) or np.isclose(node_dist, self.side_len*np.sqrt(2)):
                    self.G.add_edge(new_node, other_node,
                                    length=dist_on_sphere(self.G.nodes[new_node][&#34;projection&#34;],
                                                          self.G.nodes[other_node][&#34;projection&#34;])
                                    )
        self.current_level += 1
        self.side_len = self.side_len / 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="molgri.grids.CubePolytope" href="#molgri.grids.CubePolytope">CubePolytope</a></li>
<li><a title="molgri.grids.IcosahedronPolytope" href="#molgri.grids.IcosahedronPolytope">IcosahedronPolytope</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="molgri.grids.Polytope.divide_edges"><code class="name flex">
<span>def <span class="ident">divide_edges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Subdivide once. If previous faces are triangles, adds three points per face (half sides). If they are
squares, adds 4 points per face (half sides + middle). New points will have a higher level and will
be appropriately added to one or more faces (if on edges).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def divide_edges(self):
    &#34;&#34;&#34;
    Subdivide once. If previous faces are triangles, adds three points per face (half sides). If they are
    squares, adds 4 points per face (half sides + middle). New points will have a higher level and will
    be appropriately added to one or more faces (if on edges).
    &#34;&#34;&#34;
    # need to keep track of what to add/remove, since we can&#39;t change the network while inside the loop
    # consists of (new_point, previous_point_1, previous_point_2) to keep all info
    nodes_to_add = []
    for node_vector in self.G.nodes():
        for neighbour_vector in self.G.neighbors(node_vector):
            # this is just to avoid doing everything twice - do it for edge A-B but not B-A
            if node_vector &lt; neighbour_vector:
                # new point is just the average of the previous two
                new_point = tuple((np.array(node_vector)+np.array(neighbour_vector))/2.0)
                nodes_to_add.append((new_point, node_vector, neighbour_vector))
    # add new nodes, add edges from cont. points to the node and delete the edge between the cont. points
    for el in nodes_to_add:
        new_point, node_vector, neighbour_vector = el
        # new point will have the set of faces that both node and neighbour vector have
        faces_node_vector = self.G.nodes[node_vector][&#34;face&#34;]
        faces_neighbour_vector = self.G.nodes[neighbour_vector][&#34;face&#34;]
        # diagonals get added twice, so this is necessary
        if new_point not in self.G.nodes:
            self.G.add_node(new_point, level=self.current_level + 1,
                            face=set(faces_node_vector).intersection(faces_neighbour_vector),
                            projection=project_grid_on_sphere(np.array(new_point)[np.newaxis, :]))
        self.G.add_edge(new_point, neighbour_vector,
                        length=dist_on_sphere(self.G.nodes[new_point][&#34;projection&#34;],
                                              self.G.nodes[neighbour_vector][&#34;projection&#34;]))
        self.G.add_edge(new_point, node_vector,
                        length=dist_on_sphere(self.G.nodes[new_point][&#34;projection&#34;],
                                              self.G.nodes[neighbour_vector][&#34;projection&#34;]))
        # self.G.remove_edge(node_vector, neighbour_vector)
    # also add edges between new nodes at distance side_len or sqrt(2)*side_len
    new_level = [x for x, y in self.G.nodes(data=True) if y[&#39;level&#39;] == self.current_level+1]
    for new_node in new_level:
        # searching only second neighbours at appropriate level
        sec_neighbours = list(second_neighbours(self.G, new_node))
        sec_neighbours = [x for x in sec_neighbours if self.G.nodes[x][&#34;level&#34;] == self.current_level+1]
        for other_node in sec_neighbours:
            node_dist = np.linalg.norm(np.array(new_node)-np.array(other_node))
            # check distance criterion
            if np.isclose(node_dist, self.side_len) or np.isclose(node_dist, self.side_len*np.sqrt(2)):
                self.G.add_edge(new_node, other_node,
                                length=dist_on_sphere(self.G.nodes[new_node][&#34;projection&#34;],
                                                      self.G.nodes[other_node][&#34;projection&#34;])
                                )
    self.current_level += 1
    self.side_len = self.side_len / 2</code></pre>
</details>
</dd>
<dt id="molgri.grids.Polytope.plot_edges"><code class="name flex">
<span>def <span class="ident">plot_edges</span></span>(<span>self, ax, select_faces=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the edges between the points. Can select to display only some faces for clarity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ax</code></strong></dt>
<dd>axis</dd>
<dt><strong><code>select_faces</code></strong></dt>
<dd>a set of face numbers from 0 to (incl) 19, e.g. {0, 5}. If None, all faces are shown.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>other plotting arguments</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_edges(self, ax, select_faces=None, **kwargs):
    &#34;&#34;&#34;
    Plot the edges between the points. Can select to display only some faces for clarity.

    Args:
        ax: axis
        select_faces: a set of face numbers from 0 to (incl) 19, e.g. {0, 5}. If None, all faces are shown.
        **kwargs: other plotting arguments
    &#34;&#34;&#34;
    select_faces = set(range(20)) if select_faces is None else select_faces
    for edge in self.G.edges:
        faces_edge_1 = set(self.G.nodes[edge[0]][&#34;face&#34;])
        faces_edge_2 = set(self.G.nodes[edge[1]][&#34;face&#34;])
        # both the start and the end point of the edge must belong to one of the selected faces
        if len(faces_edge_1.intersection(select_faces)) &gt; 0 and len(faces_edge_2.intersection(select_faces)) &gt; 0:
            ax.plot(*np.array(edge).T, color=&#34;black&#34;,  **kwargs)</code></pre>
</details>
</dd>
<dt id="molgri.grids.Polytope.plot_graph"><code class="name flex">
<span>def <span class="ident">plot_graph</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the networkx graph of self.G.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_graph(self):
    &#34;&#34;&#34;
    Plot the networkx graph of self.G.
    &#34;&#34;&#34;
    node_labels = {i: tuple(np.round(i, 3)) for i in self.G.nodes}
    nx.draw_networkx(self.G, pos=nx.circular_layout(self.G), with_labels=True, labels=node_labels)</code></pre>
</details>
</dd>
<dt id="molgri.grids.Polytope.plot_points"><code class="name flex">
<span>def <span class="ident">plot_points</span></span>(<span>self, ax, select_faces: set = None, projection: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the points of the icosahedron + possible division points. Colored by level at which the point was added.
Possible to select only one or a few faces on which points are to be plotted for clarity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ax</code></strong></dt>
<dd>axis</dd>
<dt><strong><code>select_faces</code></strong></dt>
<dd>a set of face numbers from 0 to (incl) 19, e.g. {0, 5}. If None, all faces are shown.</dd>
<dt><strong><code>projection</code></strong></dt>
<dd>True if you want to plot the projected points, not the ones on surfaces of polytope</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_points(self, ax, select_faces: set = None, projection: bool = False):
    &#34;&#34;&#34;
    Plot the points of the icosahedron + possible division points. Colored by level at which the point was added.
    Possible to select only one or a few faces on which points are to be plotted for clarity.

    Args:
        ax: axis
        select_faces: a set of face numbers from 0 to (incl) 19, e.g. {0, 5}. If None, all faces are shown.
        projection: True if you want to plot the projected points, not the ones on surfaces of polytope
    &#34;&#34;&#34;
    select_faces = set(range(20)) if select_faces is None else select_faces
    level_color = [&#34;black&#34;, &#34;red&#34;, &#34;blue&#34;, &#34;green&#34;]
    for point in self.G.nodes(data=True):
        # select only points that belong to at least one of the chosen select_faces
        if len(set(point[1][&#34;face&#34;]).intersection(select_faces)) &gt; 0:
            # color selected based on the level of the node
            level_node = point[1][&#34;level&#34;]
            if projection:
                proj_node = point[1][&#34;projection&#34;]
                ax.scatter(*proj_node[0], color=level_color[level_node], s=30)
            else:
                ax.scatter(*point[0], color=level_color[level_node], s=30)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="molgri.grids.RandomEGrid"><code class="flex name class">
<span>class <span class="ident">RandomEGrid</span></span>
<span>(</span><span>N: int, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>Generate a grid with one of generation algorithms.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gen_alg</code></strong></dt>
<dd>MUST BE SET IN SUBCLASSES, algorithm name, see names given in SIX_METHOD_NAMES</dd>
<dt><strong><code>N</code></strong></dt>
<dd>number of grid points</dd>
<dt><strong><code>ordered</code></strong></dt>
<dd>if True order and truncate, else only truncate to N points</dd>
<dt><strong><code>use_saved</code></strong></dt>
<dd>if True use saved grids if available</dd>
<dt><strong><code>time_generation</code></strong></dt>
<dd>if True write out a message about time needed for generation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RandomEGrid(Grid):

    def __init__(self, N: int, **kwargs):
        super().__init__(N, gen_alg=&#34;randomE&#34;, **kwargs)

    def generate_grid(self):
        euler_angles = 2 * pi * self.rn_gen.random((self.N, 3))
        self.grid = euler2grid(euler_angles)
        # No super call because ordering not needed for random points and the number of points is exact!</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="molgri.grids.Grid" href="#molgri.grids.Grid">Grid</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="molgri.grids.RandomEGrid.generate_grid"><code class="name flex">
<span>def <span class="ident">generate_grid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_grid(self):
    euler_angles = 2 * pi * self.rn_gen.random((self.N, 3))
    self.grid = euler2grid(euler_angles)
    # No super call because ordering not needed for random points and the number of points is exact!</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="molgri.grids.RandomQGrid"><code class="flex name class">
<span>class <span class="ident">RandomQGrid</span></span>
<span>(</span><span>N: int, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>Generate a grid with one of generation algorithms.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gen_alg</code></strong></dt>
<dd>MUST BE SET IN SUBCLASSES, algorithm name, see names given in SIX_METHOD_NAMES</dd>
<dt><strong><code>N</code></strong></dt>
<dd>number of grid points</dd>
<dt><strong><code>ordered</code></strong></dt>
<dd>if True order and truncate, else only truncate to N points</dd>
<dt><strong><code>use_saved</code></strong></dt>
<dd>if True use saved grids if available</dd>
<dt><strong><code>time_generation</code></strong></dt>
<dd>if True write out a message about time needed for generation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RandomQGrid(Grid):

    def __init__(self, N: int, **kwargs):
        super().__init__(N, gen_alg=&#34;randomQ&#34;, **kwargs)

    def generate_grid(self):
        result = np.zeros((self.N, 4))
        random_num = self.rn_gen.random((self.N, 3))
        result[:, 0] = np.sqrt(1 - random_num[:, 0]) * np.sin(2 * pi * random_num[:, 1])
        result[:, 1] = np.sqrt(1 - random_num[:, 0]) * np.cos(2 * pi * random_num[:, 1])
        result[:, 2] = np.sqrt(random_num[:, 0]) * np.sin(2 * pi * random_num[:, 2])
        result[:, 3] = np.sqrt(random_num[:, 0]) * np.cos(2 * pi * random_num[:, 2])
        self.grid = quaternion2grid(result)
        # No super call because ordering not needed for random points and the number of points is exact!</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="molgri.grids.Grid" href="#molgri.grids.Grid">Grid</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="molgri.grids.RandomQGrid.generate_grid"><code class="name flex">
<span>def <span class="ident">generate_grid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_grid(self):
    result = np.zeros((self.N, 4))
    random_num = self.rn_gen.random((self.N, 3))
    result[:, 0] = np.sqrt(1 - random_num[:, 0]) * np.sin(2 * pi * random_num[:, 1])
    result[:, 1] = np.sqrt(1 - random_num[:, 0]) * np.cos(2 * pi * random_num[:, 1])
    result[:, 2] = np.sqrt(random_num[:, 0]) * np.sin(2 * pi * random_num[:, 2])
    result[:, 3] = np.sqrt(random_num[:, 0]) * np.cos(2 * pi * random_num[:, 2])
    self.grid = quaternion2grid(result)
    # No super call because ordering not needed for random points and the number of points is exact!</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="molgri.grids.SystemEGrid"><code class="flex name class">
<span>class <span class="ident">SystemEGrid</span></span>
<span>(</span><span>N: int, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>Generate a grid with one of generation algorithms.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gen_alg</code></strong></dt>
<dd>MUST BE SET IN SUBCLASSES, algorithm name, see names given in SIX_METHOD_NAMES</dd>
<dt><strong><code>N</code></strong></dt>
<dd>number of grid points</dd>
<dt><strong><code>ordered</code></strong></dt>
<dd>if True order and truncate, else only truncate to N points</dd>
<dt><strong><code>use_saved</code></strong></dt>
<dd>if True use saved grids if available</dd>
<dt><strong><code>time_generation</code></strong></dt>
<dd>if True write out a message about time needed for generation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SystemEGrid(Grid):

    def __init__(self, N: int, **kwargs):
        super().__init__(N, gen_alg=&#34;systemE&#34;, **kwargs)

    def generate_grid(self):
        self.grid = []
        num_points = 1
        while len(self.grid) &lt; self.N:
            phis = np.linspace(0, 2 * pi, num_points)
            thetas = np.linspace(0, 2 * pi, num_points)
            psis = np.linspace(0, 2 * pi, num_points)
            euler_meshgrid = np.array(np.meshgrid(*(phis, thetas, psis)), dtype=float)
            euler_meshgrid = euler_meshgrid.reshape((3, -1)).T
            # convert to a grid
            self.grid = euler2grid(euler_meshgrid)
            self.grid = np.unique(np.round(self.grid, UNIQUE_TOL), axis=0)
            num_points += 1
        super().generate_grid()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="molgri.grids.Grid" href="#molgri.grids.Grid">Grid</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="molgri.grids.SystemEGrid.generate_grid"><code class="name flex">
<span>def <span class="ident">generate_grid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_grid(self):
    self.grid = []
    num_points = 1
    while len(self.grid) &lt; self.N:
        phis = np.linspace(0, 2 * pi, num_points)
        thetas = np.linspace(0, 2 * pi, num_points)
        psis = np.linspace(0, 2 * pi, num_points)
        euler_meshgrid = np.array(np.meshgrid(*(phis, thetas, psis)), dtype=float)
        euler_meshgrid = euler_meshgrid.reshape((3, -1)).T
        # convert to a grid
        self.grid = euler2grid(euler_meshgrid)
        self.grid = np.unique(np.round(self.grid, UNIQUE_TOL), axis=0)
        num_points += 1
    super().generate_grid()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="molgri.grids.ZeroGrid"><code class="flex name class">
<span>class <span class="ident">ZeroGrid</span></span>
<span>(</span><span>N=1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Use this rotation grid if you want no rotations at all. Consists of only one point, a nit vector in z-direction.</p>
<p>Generate a grid with one of generation algorithms.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gen_alg</code></strong></dt>
<dd>MUST BE SET IN SUBCLASSES, algorithm name, see names given in SIX_METHOD_NAMES</dd>
<dt><strong><code>N</code></strong></dt>
<dd>number of grid points</dd>
<dt><strong><code>ordered</code></strong></dt>
<dd>if True order and truncate, else only truncate to N points</dd>
<dt><strong><code>use_saved</code></strong></dt>
<dd>if True use saved grids if available</dd>
<dt><strong><code>time_generation</code></strong></dt>
<dd>if True write out a message about time needed for generation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ZeroGrid(Grid):
    &#34;&#34;&#34;
    Use this rotation grid if you want no rotations at all. Consists of only one point, a nit vector in z-direction.
    &#34;&#34;&#34;

    def __init__(self, N=1, **kwargs):
        super().__init__(N, gen_alg=&#34;zero&#34;, **kwargs)
        self.standard_name = &#34;zero&#34;

    def generate_grid(self):
        self.grid = np.array([[0, 0, 1]])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="molgri.grids.Grid" href="#molgri.grids.Grid">Grid</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="molgri.grids.ZeroGrid.generate_grid"><code class="name flex">
<span>def <span class="ident">generate_grid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_grid(self):
    self.grid = np.array([[0, 0, 1]])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="molgri" href="index.html">molgri</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="molgri.grids.build_grid" href="#molgri.grids.build_grid">build_grid</a></code></li>
<li><code><a title="molgri.grids.order_grid_points" href="#molgri.grids.order_grid_points">order_grid_points</a></code></li>
<li><code><a title="molgri.grids.project_grid_on_sphere" href="#molgri.grids.project_grid_on_sphere">project_grid_on_sphere</a></code></li>
<li><code><a title="molgri.grids.second_neighbours" href="#molgri.grids.second_neighbours">second_neighbours</a></code></li>
<li><code><a title="molgri.grids.select_next_gridpoint" href="#molgri.grids.select_next_gridpoint">select_next_gridpoint</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="molgri.grids.Cube3DGrid" href="#molgri.grids.Cube3DGrid">Cube3DGrid</a></code></h4>
</li>
<li>
<h4><code><a title="molgri.grids.Cube4DGrid" href="#molgri.grids.Cube4DGrid">Cube4DGrid</a></code></h4>
<ul class="">
<li><code><a title="molgri.grids.Cube4DGrid.generate_grid" href="#molgri.grids.Cube4DGrid.generate_grid">generate_grid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="molgri.grids.CubePolytope" href="#molgri.grids.CubePolytope">CubePolytope</a></code></h4>
</li>
<li>
<h4><code><a title="molgri.grids.FullGrid" href="#molgri.grids.FullGrid">FullGrid</a></code></h4>
<ul class="">
<li><code><a title="molgri.grids.FullGrid.get_full_grid_name" href="#molgri.grids.FullGrid.get_full_grid_name">get_full_grid_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="molgri.grids.Grid" href="#molgri.grids.Grid">Grid</a></code></h4>
<ul class="two-column">
<li><code><a title="molgri.grids.Grid.as_euler" href="#molgri.grids.Grid.as_euler">as_euler</a></code></li>
<li><code><a title="molgri.grids.Grid.as_quaternion" href="#molgri.grids.Grid.as_quaternion">as_quaternion</a></code></li>
<li><code><a title="molgri.grids.Grid.generate_and_time" href="#molgri.grids.Grid.generate_and_time">generate_and_time</a></code></li>
<li><code><a title="molgri.grids.Grid.generate_grid" href="#molgri.grids.Grid.generate_grid">generate_grid</a></code></li>
<li><code><a title="molgri.grids.Grid.get_grid" href="#molgri.grids.Grid.get_grid">get_grid</a></code></li>
<li><code><a title="molgri.grids.Grid.save_grid" href="#molgri.grids.Grid.save_grid">save_grid</a></code></li>
<li><code><a title="molgri.grids.Grid.save_grid_txt" href="#molgri.grids.Grid.save_grid_txt">save_grid_txt</a></code></li>
<li><code><a title="molgri.grids.Grid.save_statistics" href="#molgri.grids.Grid.save_statistics">save_statistics</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="molgri.grids.IcoGrid" href="#molgri.grids.IcoGrid">IcoGrid</a></code></h4>
</li>
<li>
<h4><code><a title="molgri.grids.IcosahedronPolytope" href="#molgri.grids.IcosahedronPolytope">IcosahedronPolytope</a></code></h4>
</li>
<li>
<h4><code><a title="molgri.grids.Polyhedron3DGrid" href="#molgri.grids.Polyhedron3DGrid">Polyhedron3DGrid</a></code></h4>
<ul class="">
<li><code><a title="molgri.grids.Polyhedron3DGrid.generate_grid" href="#molgri.grids.Polyhedron3DGrid.generate_grid">generate_grid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="molgri.grids.Polytope" href="#molgri.grids.Polytope">Polytope</a></code></h4>
<ul class="">
<li><code><a title="molgri.grids.Polytope.divide_edges" href="#molgri.grids.Polytope.divide_edges">divide_edges</a></code></li>
<li><code><a title="molgri.grids.Polytope.plot_edges" href="#molgri.grids.Polytope.plot_edges">plot_edges</a></code></li>
<li><code><a title="molgri.grids.Polytope.plot_graph" href="#molgri.grids.Polytope.plot_graph">plot_graph</a></code></li>
<li><code><a title="molgri.grids.Polytope.plot_points" href="#molgri.grids.Polytope.plot_points">plot_points</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="molgri.grids.RandomEGrid" href="#molgri.grids.RandomEGrid">RandomEGrid</a></code></h4>
<ul class="">
<li><code><a title="molgri.grids.RandomEGrid.generate_grid" href="#molgri.grids.RandomEGrid.generate_grid">generate_grid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="molgri.grids.RandomQGrid" href="#molgri.grids.RandomQGrid">RandomQGrid</a></code></h4>
<ul class="">
<li><code><a title="molgri.grids.RandomQGrid.generate_grid" href="#molgri.grids.RandomQGrid.generate_grid">generate_grid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="molgri.grids.SystemEGrid" href="#molgri.grids.SystemEGrid">SystemEGrid</a></code></h4>
<ul class="">
<li><code><a title="molgri.grids.SystemEGrid.generate_grid" href="#molgri.grids.SystemEGrid.generate_grid">generate_grid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="molgri.grids.ZeroGrid" href="#molgri.grids.ZeroGrid">ZeroGrid</a></code></h4>
<ul class="">
<li><code><a title="molgri.grids.ZeroGrid.generate_grid" href="#molgri.grids.ZeroGrid.generate_grid">generate_grid</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>