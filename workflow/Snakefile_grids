"""
All workflow (anything to do with input/output files, creating figures etc. that only has to do with grids.
"""

from time import time

import numpy as np

# add molgri directory
import sys
sys.path.append(".")

from molgri.paths import PATH_OUTPUT_AUTOSAVE, PATH_OUTPUT_LOGGING
from workflow.snakemake_utils import log_the_run

pepfile: "workflow/grid_pep.yaml"
grids = pep.sample_table

rule all_grids:
    input:
        expand(f"{PATH_OUTPUT_AUTOSAVE}{{grid_identifier}}_full_array.npy", grid_identifier=grids.index)

rule run_grid:
    """
    This rule should provide a full grid and its geometric parameters.
    """
    output:
        full_array = f"{PATH_OUTPUT_AUTOSAVE}{{grid_identifier}}_full_array.npy",
        adjacency_array = f"{PATH_OUTPUT_AUTOSAVE}{{grid_identifier}}_adjacency_array.npz",
        distances_array = f"{PATH_OUTPUT_AUTOSAVE}{{grid_identifier}}_distances_array.npz",
        borders_array= f"{PATH_OUTPUT_AUTOSAVE}{{grid_identifier}}_borders_array.npz",
        volumes = f"{PATH_OUTPUT_AUTOSAVE}{{grid_identifier}}_volumes.npy",
    log: f"{PATH_OUTPUT_LOGGING}{{grid_identifier}}_full_array.log"
    params:
        b = lambda wc: grids.loc[wc.grid_identifier,"b_grid_name"],
        o = lambda wc: grids.loc[wc.grid_identifier,"o_grid_name"],
        t = lambda wc: grids.loc[wc.grid_identifier,"t_grid_name"]
    run:
        t1 = time()
        from molgri.space.fullgrid import FullGrid
        from scipy import sparse
        fg = FullGrid(params.b, params.o, params.t)

        # save full array
        np.save(output.full_array, fg.get_full_grid_as_array())
        # save geometric properties
        sparse.save_npz(output.adjacency_array, fg.get_full_adjacency())
        sparse.save_npz(output.borders_array,fg.get_full_borders())
        sparse.save_npz(output.distances_array,fg.get_full_distances())
        np.save(output.volumes,fg.get_total_volumes())
        t2 = time()
        log_the_run(wildcards.grid_identifier, None, output, log[0], params, t2-t1)